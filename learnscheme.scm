;希望我能明白怎么用Scheme求导

;函数定义
;把一个lambda表达式用define过程放到一个变量里
(define x
  (lambda (i)
    (display i)
    (newline))
(x "hello")





;Scheme的变量类型不是固定的，可以随时改变。现在是整数，过一会儿是lambda表达式

(define x 42)
;怪了，Emacs没给set!过程加高亮
;set!可以重设变量值
(set! x
      (lambda (i)
	(display (* i 30))))
(x 256)

;数学运算
;'*' -> 乘
;'/' -> 除

;布尔型数据
;
;#t -> True，代表真值
;
;#f -> False,表错误
;
;相关的过程:
;
;boolean? -> 检查数据类型
;类型为boolean则返回#t
;其他全返#f
;
;第一次写居然没写问号😓
;
;not -> 只要数据不是'#f'，就返回#f
;
;布尔类型就这么多:|
;
;#####################################
;
;数字一类的数据
;
;整数，比如9
;
;有理数，比如2/5
;
;实数，比如Pi(圆周率)
;
;复数，比如2+3i
;
;
;现在用的tinyscheme识别不了复数，分数带分号也不行,唉
;我就不该看给MITscheme写的Handbook
;只好用(/ 1 3)表示1/3
;复数昨整啊
;坐等guile
;
;有理数指小数部分有限或无限循环的数
;
;标准定义是有理数可以被表达为整数a/正整数b
;
;
;
;用集合的理念来看
;
;整数 ⊆ 有理数 ⊆ 实数 ⊆ 复数
;
;
;相关的过程
;
;
;number? -- 检查数字用(是数字就行)
;
;complex? -- 检查复数用
;
;real? -- 检查实数用
;
;rational? -- 检查有理数用
;
;integer? -- 检查整数用
;

(display "例子" (newline))

(real? (acos -1)) ;#t

;与(real? pi)等效

;
;整数进制随便选择.
;
;#b前缀 --> 二进制
;
;#o --> 八进制
;
;#x --> 十六进制
;
;我好像用不到啊……
;
;
;eqv? 和 = --> 检查数相等性
;
;不过eqv?是从类型角度出发的，即使一个整数和有理数大小相等，比如5和5.0，用eqv?检查仍然为#f，当然了，大小他也要查，不一样还是#f
;
;=只检查数的大小是否相等,但是万一参数中有不属于number的，立马就报Error
;
;(= 32 #f)
;Error: =: argument 2 must be: number
;
;其它的数字比较还包括 <,<=,>,>=，意思一看就懂
;
;都只适合两个参数，别整多了
;
;
;+, -,*,/, expt等数学运算过程具有我们期待的功能。
;(expt 2 3)  ;就是2的3次方，expt过程用于幂乘方
;
;(expt 4 (/ 1 2))
;返回2.0，变成有理数了，输的是整数啊
;
;
;
;
;对于一个参数的情况，- 和/过程会分别得到反数和倒数的结果。
;
;max和min 过程会分别返回提供给它们的参数的最大值和最小值。它们可以支持任何的数字。
;
;abs过程会返回提供给它参数的绝对值。
;
;atan, exp, 和 sqrt等过程分别返回参数的余切、自然反对数和开方值。
;
;为什么，cos和sin过程接受的是弧度
;
;360度=2π
;
;tinyscheme完全无法接受pi作为参数
;(define pi (acos -1))曲线救国：|
;
;symbols通常在Scheme程序中被用来当做变量的标识，求值后可以得到变量所代表的值。然而symbols是一种简单数据类型，而且就像characers、numbers以及其它类型数据一样，是Scheme中可以传递的有效值类型。
;
;创建一个单纯的symbol而非变量时，你需要使用quote过程：
;
;
;Scheme的symbols类型通常都是不区分大小写的。因此Calorie 和calorie是等价的
;
;
;Scheme中字符型数据通过在字符前加 #\前缀来表示。像#\c就表示字符c。那些非可视字符会有更多的描述名称，例如，#\newline, #\tab。空格字符可以写成 #\，或者可读性更好一些的#\space。
;
;字符串类型是由字符组成的序列
;
;
;终于到我最喜欢的string了：|
;
;
;总之，用引号圈起来就好了
;
;
;检测一个值是否是字符串类型的过程是string?。
;
;
;一个给定字符串数据中的字符可以分别被访问和更改。 通过向string-ref过程传递一个字符串和一个从0开始的索引号，可以返回该字符串指定索引号位置的字符。
;
;
;你可以定义一个指定长度的字符串，然后用期望的字符来填充它。

;(define a-3-char-long-string (make-string 3))
;
;(define hello (string #\H #\e #\l #\l #\o)) 
;(string-set! hello 1 #\a)
;hello
;=>  "Hallo"
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;



